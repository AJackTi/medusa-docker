"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-currency-input-field";
exports.ids = ["vendor-chunks/react-currency-input-field"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-currency-input-field/dist/index.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-currency-input-field/dist/index.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanValue: () => (/* binding */ cleanValue),\n/* harmony export */   \"default\": () => (/* binding */ CurrencyInput),\n/* harmony export */   formatValue: () => (/* binding */ formatValue)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n\nvar __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  };\n  return __assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\n/**\n * Escape regex char\n *\n * See: https://stackoverflow.com/questions/17885855/use-dynamic-variable-string-as-regex-pattern-in-javascript\n */\nvar escapeRegExp = function (stringToGoIntoTheRegex) {\n    return stringToGoIntoTheRegex.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n};\n\nvar abbrMap = { k: 1000, m: 1000000, b: 1000000000 };\n/**\n * Parse a value with abbreviation e.g 1k = 1000\n */\nvar parseAbbrValue = function (value, decimalSeparator) {\n    if (decimalSeparator === void 0) { decimalSeparator = '.'; }\n    var reg = new RegExp(\"(\\\\d+(\".concat(escapeRegExp(decimalSeparator), \"\\\\d*)?)([kmb])$\"), 'i');\n    var match = value.match(reg);\n    if (match) {\n        var digits = match[1], abbr = match[3];\n        var multiplier = abbrMap[abbr.toLowerCase()];\n        return Number(digits.replace(decimalSeparator, '.')) * multiplier;\n    }\n    return undefined;\n};\n\n/**\n * Remove group separator from value eg. 1,000 > 1000\n */\nvar removeSeparators = function (value, separator) {\n    if (separator === void 0) { separator = ','; }\n    var reg = new RegExp(escapeRegExp(separator), 'g');\n    return value.replace(reg, '');\n};\n\n/**\n * Remove invalid characters\n */\nvar removeInvalidChars = function (value, validChars) {\n    var chars = escapeRegExp(validChars.join(''));\n    var reg = new RegExp(\"[^\\\\d\".concat(chars, \"]\"), 'gi');\n    return value.replace(reg, '');\n};\n\n/**\n * Remove prefix, separators and extra decimals from value\n */\nvar cleanValue = function (_a) {\n    var value = _a.value, _b = _a.groupSeparator, groupSeparator = _b === void 0 ? ',' : _b, _c = _a.decimalSeparator, decimalSeparator = _c === void 0 ? '.' : _c, _d = _a.allowDecimals, allowDecimals = _d === void 0 ? true : _d, _e = _a.decimalsLimit, decimalsLimit = _e === void 0 ? 2 : _e, _f = _a.allowNegativeValue, allowNegativeValue = _f === void 0 ? true : _f, _g = _a.disableAbbreviations, disableAbbreviations = _g === void 0 ? false : _g, _h = _a.prefix, prefix = _h === void 0 ? '' : _h, _j = _a.transformRawValue, transformRawValue = _j === void 0 ? function (rawValue) { return rawValue; } : _j;\n    var transformedValue = transformRawValue(value);\n    if (transformedValue === '-') {\n        return transformedValue;\n    }\n    var abbreviations = disableAbbreviations ? [] : ['k', 'm', 'b'];\n    var reg = new RegExp(\"((^|\\\\D)-\\\\d)|(-\".concat(escapeRegExp(prefix), \")\"));\n    var isNegative = reg.test(transformedValue);\n    // Is there a digit before the prefix? eg. 1$\n    var _k = RegExp(\"(\\\\d+)-?\".concat(escapeRegExp(prefix))).exec(value) || [], prefixWithValue = _k[0], preValue = _k[1];\n    var withoutPrefix = prefix\n        ? prefixWithValue\n            ? transformedValue.replace(prefixWithValue, '').concat(preValue)\n            : transformedValue.replace(prefix, '')\n        : transformedValue;\n    var withoutSeparators = removeSeparators(withoutPrefix, groupSeparator);\n    var withoutInvalidChars = removeInvalidChars(withoutSeparators, __spreadArray([\n        groupSeparator,\n        decimalSeparator\n    ], abbreviations, true));\n    var valueOnly = withoutInvalidChars;\n    if (!disableAbbreviations) {\n        // disallow letter without number\n        if (abbreviations.some(function (letter) { return letter === withoutInvalidChars.toLowerCase().replace(decimalSeparator, ''); })) {\n            return '';\n        }\n        var parsed = parseAbbrValue(withoutInvalidChars, decimalSeparator);\n        if (parsed) {\n            valueOnly = String(parsed);\n        }\n    }\n    var includeNegative = isNegative && allowNegativeValue ? '-' : '';\n    if (decimalSeparator && valueOnly.includes(decimalSeparator)) {\n        var _l = withoutInvalidChars.split(decimalSeparator), int = _l[0], decimals = _l[1];\n        var trimmedDecimals = decimalsLimit && decimals ? decimals.slice(0, decimalsLimit) : decimals;\n        var includeDecimals = allowDecimals ? \"\".concat(decimalSeparator).concat(trimmedDecimals) : '';\n        return \"\".concat(includeNegative).concat(int).concat(includeDecimals);\n    }\n    return \"\".concat(includeNegative).concat(valueOnly);\n};\n\nvar fixedDecimalValue = function (value, decimalSeparator, fixedDecimalLength) {\n    if (fixedDecimalLength !== undefined && value.length > 1) {\n        if (fixedDecimalLength === 0) {\n            return value.replace(decimalSeparator, '');\n        }\n        if (value.includes(decimalSeparator)) {\n            var _a = value.split(decimalSeparator), int = _a[0], decimals = _a[1];\n            if (decimals.length === fixedDecimalLength) {\n                return value;\n            }\n            if (decimals.length > fixedDecimalLength) {\n                return \"\".concat(int).concat(decimalSeparator).concat(decimals.slice(0, fixedDecimalLength));\n            }\n        }\n        var reg = value.length > fixedDecimalLength\n            ? new RegExp(\"(\\\\d+)(\\\\d{\".concat(fixedDecimalLength, \"})\"))\n            : new RegExp(\"(\\\\d)(\\\\d+)\");\n        var match = value.match(reg);\n        if (match) {\n            var int = match[1], decimals = match[2];\n            return \"\".concat(int).concat(decimalSeparator).concat(decimals);\n        }\n    }\n    return value;\n};\n\nvar getSuffix = function (value, _a) {\n    var _b = _a.groupSeparator, groupSeparator = _b === void 0 ? ',' : _b, _c = _a.decimalSeparator, decimalSeparator = _c === void 0 ? '.' : _c;\n    var suffixReg = new RegExp(\"\\\\d([^\".concat(escapeRegExp(groupSeparator)).concat(escapeRegExp(decimalSeparator), \"0-9]+)\"));\n    var suffixMatch = value.match(suffixReg);\n    return suffixMatch ? suffixMatch[1] : undefined;\n};\n\n/**\n * Format value with decimal separator, group separator and prefix\n */\nvar formatValue = function (options) {\n    var _value = options.value, decimalSeparator = options.decimalSeparator, intlConfig = options.intlConfig, decimalScale = options.decimalScale, _a = options.prefix, prefix = _a === void 0 ? '' : _a, _b = options.suffix, suffix = _b === void 0 ? '' : _b;\n    if (_value === '' || _value === undefined) {\n        return '';\n    }\n    if (_value === '-') {\n        return '-';\n    }\n    var isNegative = new RegExp(\"^\\\\d?-\".concat(prefix ? \"\".concat(escapeRegExp(prefix), \"?\") : '', \"\\\\d\")).test(_value);\n    var value = decimalSeparator !== '.'\n        ? replaceDecimalSeparator(_value, decimalSeparator, isNegative)\n        : _value;\n    if (decimalSeparator && decimalSeparator !== '-' && value.startsWith(decimalSeparator)) {\n        value = '0' + value;\n    }\n    var defaultNumberFormatOptions = {\n        minimumFractionDigits: decimalScale || 0,\n        maximumFractionDigits: 20,\n    };\n    var numberFormatter = intlConfig\n        ? new Intl.NumberFormat(intlConfig.locale, intlConfig.currency\n            ? __assign(__assign({}, defaultNumberFormatOptions), { style: 'currency', currency: intlConfig.currency }) : defaultNumberFormatOptions)\n        : new Intl.NumberFormat(undefined, defaultNumberFormatOptions);\n    var parts = numberFormatter.formatToParts(Number(value));\n    var formatted = replaceParts(parts, options);\n    // Does intl formatting add a suffix?\n    var intlSuffix = getSuffix(formatted, __assign({}, options));\n    // Include decimal separator if user input ends with decimal separator\n    var includeDecimalSeparator = _value.slice(-1) === decimalSeparator ? decimalSeparator : '';\n    var _c = value.match(RegExp('\\\\d+\\\\.(\\\\d+)')) || [], decimals = _c[1];\n    // Keep original decimal padding if no decimalScale\n    if (decimalScale === undefined && decimals && decimalSeparator) {\n        if (formatted.includes(decimalSeparator)) {\n            formatted = formatted.replace(RegExp(\"(\\\\d+)(\".concat(escapeRegExp(decimalSeparator), \")(\\\\d+)\"), 'g'), \"$1$2\".concat(decimals));\n        }\n        else {\n            if (intlSuffix && !suffix) {\n                formatted = formatted.replace(intlSuffix, \"\".concat(decimalSeparator).concat(decimals).concat(intlSuffix));\n            }\n            else {\n                formatted = \"\".concat(formatted).concat(decimalSeparator).concat(decimals);\n            }\n        }\n    }\n    if (suffix && includeDecimalSeparator) {\n        return \"\".concat(formatted).concat(includeDecimalSeparator).concat(suffix);\n    }\n    if (intlSuffix && includeDecimalSeparator) {\n        return formatted.replace(intlSuffix, \"\".concat(includeDecimalSeparator).concat(intlSuffix));\n    }\n    if (intlSuffix && suffix) {\n        return formatted.replace(intlSuffix, \"\".concat(includeDecimalSeparator).concat(suffix));\n    }\n    return [formatted, includeDecimalSeparator, suffix].join('');\n};\n/**\n * Before converting to Number, decimal separator has to be .\n */\nvar replaceDecimalSeparator = function (value, decimalSeparator, isNegative) {\n    var newValue = value;\n    if (decimalSeparator && decimalSeparator !== '.') {\n        newValue = newValue.replace(RegExp(escapeRegExp(decimalSeparator), 'g'), '.');\n        if (isNegative && decimalSeparator === '-') {\n            newValue = \"-\".concat(newValue.slice(1));\n        }\n    }\n    return newValue;\n};\nvar replaceParts = function (parts, _a) {\n    var prefix = _a.prefix, groupSeparator = _a.groupSeparator, decimalSeparator = _a.decimalSeparator, decimalScale = _a.decimalScale, _b = _a.disableGroupSeparators, disableGroupSeparators = _b === void 0 ? false : _b;\n    return parts\n        .reduce(function (prev, _a, i) {\n        var type = _a.type, value = _a.value;\n        if (i === 0 && prefix) {\n            if (type === 'minusSign') {\n                return [value, prefix];\n            }\n            if (type === 'currency') {\n                return __spreadArray(__spreadArray([], prev, true), [prefix], false);\n            }\n            return [prefix, value];\n        }\n        if (type === 'currency') {\n            return prefix ? prev : __spreadArray(__spreadArray([], prev, true), [value], false);\n        }\n        if (type === 'group') {\n            return !disableGroupSeparators\n                ? __spreadArray(__spreadArray([], prev, true), [groupSeparator !== undefined ? groupSeparator : value], false) : prev;\n        }\n        if (type === 'decimal') {\n            if (decimalScale !== undefined && decimalScale === 0) {\n                return prev;\n            }\n            return __spreadArray(__spreadArray([], prev, true), [decimalSeparator !== undefined ? decimalSeparator : value], false);\n        }\n        if (type === 'fraction') {\n            return __spreadArray(__spreadArray([], prev, true), [decimalScale !== undefined ? value.slice(0, decimalScale) : value], false);\n        }\n        return __spreadArray(__spreadArray([], prev, true), [value], false);\n    }, [''])\n        .join('');\n};\n\nvar defaultConfig = {\n    currencySymbol: '',\n    groupSeparator: '',\n    decimalSeparator: '',\n    prefix: '',\n    suffix: '',\n};\n/**\n * Get locale config from input or default\n */\nvar getLocaleConfig = function (intlConfig) {\n    var _a = intlConfig || {}, locale = _a.locale, currency = _a.currency;\n    var numberFormatter = locale\n        ? new Intl.NumberFormat(locale, currency ? { currency: currency, style: 'currency' } : undefined)\n        : new Intl.NumberFormat();\n    return numberFormatter.formatToParts(1000.1).reduce(function (prev, curr, i) {\n        if (curr.type === 'currency') {\n            if (i === 0) {\n                return __assign(__assign({}, prev), { currencySymbol: curr.value, prefix: curr.value });\n            }\n            else {\n                return __assign(__assign({}, prev), { currencySymbol: curr.value, suffix: curr.value });\n            }\n        }\n        if (curr.type === 'group') {\n            return __assign(__assign({}, prev), { groupSeparator: curr.value });\n        }\n        if (curr.type === 'decimal') {\n            return __assign(__assign({}, prev), { decimalSeparator: curr.value });\n        }\n        return prev;\n    }, defaultConfig);\n};\n\nvar isNumber = function (input) { return RegExp(/\\d/, 'gi').test(input); };\n\nvar padTrimValue = function (value, decimalSeparator, decimalScale) {\n    if (decimalSeparator === void 0) { decimalSeparator = '.'; }\n    if (decimalScale === undefined || value === '' || value === undefined) {\n        return value;\n    }\n    if (!value.match(/\\d/g)) {\n        return '';\n    }\n    var _a = value.split(decimalSeparator), int = _a[0], decimals = _a[1];\n    if (decimalScale === 0) {\n        return int;\n    }\n    var newValue = decimals || '';\n    if (newValue.length < decimalScale) {\n        while (newValue.length < decimalScale) {\n            newValue += '0';\n        }\n    }\n    else {\n        newValue = newValue.slice(0, decimalScale);\n    }\n    return \"\".concat(int).concat(decimalSeparator).concat(newValue);\n};\n\n/**\n * Based on the last key stroke and the cursor position, update the value\n * and reposition the cursor to the right place\n */\nvar repositionCursor = function (_a) {\n    var selectionStart = _a.selectionStart, value = _a.value, lastKeyStroke = _a.lastKeyStroke, stateValue = _a.stateValue, groupSeparator = _a.groupSeparator;\n    var cursorPosition = selectionStart;\n    var modifiedValue = value;\n    if (stateValue && cursorPosition) {\n        var splitValue = value.split('');\n        // if cursor is to right of groupSeparator and backspace pressed, delete the character to the left of the separator and reposition the cursor\n        if (lastKeyStroke === 'Backspace' && stateValue[cursorPosition] === groupSeparator) {\n            splitValue.splice(cursorPosition - 1, 1);\n            cursorPosition -= 1;\n        }\n        // if cursor is to left of groupSeparator and delete pressed, delete the character to the right of the separator and reposition the cursor\n        if (lastKeyStroke === 'Delete' && stateValue[cursorPosition] === groupSeparator) {\n            splitValue.splice(cursorPosition, 1);\n            cursorPosition += 1;\n        }\n        modifiedValue = splitValue.join('');\n        return { modifiedValue: modifiedValue, cursorPosition: cursorPosition };\n    }\n    return { modifiedValue: modifiedValue, cursorPosition: selectionStart };\n};\n\nvar CurrencyInput = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (_a, ref) {\n    var _b = _a.allowDecimals, allowDecimals = _b === void 0 ? true : _b, _c = _a.allowNegativeValue, allowNegativeValue = _c === void 0 ? true : _c, id = _a.id, name = _a.name, className = _a.className, customInput = _a.customInput, decimalsLimit = _a.decimalsLimit, defaultValue = _a.defaultValue, _d = _a.disabled, disabled = _d === void 0 ? false : _d, userMaxLength = _a.maxLength, userValue = _a.value, onValueChange = _a.onValueChange, fixedDecimalLength = _a.fixedDecimalLength, placeholder = _a.placeholder, decimalScale = _a.decimalScale, prefix = _a.prefix, suffix = _a.suffix, intlConfig = _a.intlConfig, step = _a.step, min = _a.min, max = _a.max, _e = _a.disableGroupSeparators, disableGroupSeparators = _e === void 0 ? false : _e, _f = _a.disableAbbreviations, disableAbbreviations = _f === void 0 ? false : _f, _decimalSeparator = _a.decimalSeparator, _groupSeparator = _a.groupSeparator, onChange = _a.onChange, onFocus = _a.onFocus, onBlur = _a.onBlur, onKeyDown = _a.onKeyDown, onKeyUp = _a.onKeyUp, transformRawValue = _a.transformRawValue, _g = _a.formatValueOnBlur, formatValueOnBlur = _g === void 0 ? true : _g, props = __rest(_a, [\"allowDecimals\", \"allowNegativeValue\", \"id\", \"name\", \"className\", \"customInput\", \"decimalsLimit\", \"defaultValue\", \"disabled\", \"maxLength\", \"value\", \"onValueChange\", \"fixedDecimalLength\", \"placeholder\", \"decimalScale\", \"prefix\", \"suffix\", \"intlConfig\", \"step\", \"min\", \"max\", \"disableGroupSeparators\", \"disableAbbreviations\", \"decimalSeparator\", \"groupSeparator\", \"onChange\", \"onFocus\", \"onBlur\", \"onKeyDown\", \"onKeyUp\", \"transformRawValue\", \"formatValueOnBlur\"]);\n    if (_decimalSeparator && isNumber(_decimalSeparator)) {\n        throw new Error('decimalSeparator cannot be a number');\n    }\n    if (_groupSeparator && isNumber(_groupSeparator)) {\n        throw new Error('groupSeparator cannot be a number');\n    }\n    var localeConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () { return getLocaleConfig(intlConfig); }, [intlConfig]);\n    var decimalSeparator = _decimalSeparator || localeConfig.decimalSeparator || '';\n    var groupSeparator = _groupSeparator || localeConfig.groupSeparator || '';\n    if (decimalSeparator &&\n        groupSeparator &&\n        decimalSeparator === groupSeparator &&\n        disableGroupSeparators === false) {\n        throw new Error('decimalSeparator cannot be the same as groupSeparator');\n    }\n    var formatValueOptions = {\n        decimalSeparator: decimalSeparator,\n        groupSeparator: groupSeparator,\n        disableGroupSeparators: disableGroupSeparators,\n        intlConfig: intlConfig,\n        prefix: prefix || localeConfig.prefix,\n        suffix: suffix,\n    };\n    var cleanValueOptions = {\n        decimalSeparator: decimalSeparator,\n        groupSeparator: groupSeparator,\n        allowDecimals: allowDecimals,\n        decimalsLimit: decimalsLimit || fixedDecimalLength || 2,\n        allowNegativeValue: allowNegativeValue,\n        disableAbbreviations: disableAbbreviations,\n        prefix: prefix || localeConfig.prefix,\n        transformRawValue: transformRawValue,\n    };\n    var _h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function () {\n        return defaultValue != null\n            ? formatValue(__assign(__assign({}, formatValueOptions), { decimalScale: decimalScale, value: String(defaultValue) }))\n            : userValue != null\n                ? formatValue(__assign(__assign({}, formatValueOptions), { decimalScale: decimalScale, value: String(userValue) }))\n                : '';\n    }), stateValue = _h[0], setStateValue = _h[1];\n    var _j = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false), dirty = _j[0], setDirty = _j[1];\n    var _k = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), cursor = _k[0], setCursor = _k[1];\n    var _l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), changeCount = _l[0], setChangeCount = _l[1];\n    var _m = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), lastKeyStroke = _m[0], setLastKeyStroke = _m[1];\n    var inputRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, function () { return inputRef.current; });\n    /**\n     * Process change in value\n     */\n    var processChange = function (value, selectionStart) {\n        setDirty(true);\n        var _a = repositionCursor({\n            selectionStart: selectionStart,\n            value: value,\n            lastKeyStroke: lastKeyStroke,\n            stateValue: stateValue,\n            groupSeparator: groupSeparator,\n        }), modifiedValue = _a.modifiedValue, cursorPosition = _a.cursorPosition;\n        var stringValue = cleanValue(__assign({ value: modifiedValue }, cleanValueOptions));\n        if (userMaxLength && stringValue.replace(/-/g, '').length > userMaxLength) {\n            return;\n        }\n        if (stringValue === '' || stringValue === '-' || stringValue === decimalSeparator) {\n            onValueChange && onValueChange(undefined, name, { float: null, formatted: '', value: '' });\n            setStateValue(stringValue);\n            // Always sets cursor after '-' or decimalSeparator input\n            setCursor(1);\n            return;\n        }\n        var stringValueWithoutSeparator = decimalSeparator\n            ? stringValue.replace(decimalSeparator, '.')\n            : stringValue;\n        var numberValue = parseFloat(stringValueWithoutSeparator);\n        var formattedValue = formatValue(__assign({ value: stringValue }, formatValueOptions));\n        if (cursorPosition != null) {\n            // Prevent cursor jumping\n            var newCursor = cursorPosition + (formattedValue.length - value.length);\n            newCursor = newCursor <= 0 ? (prefix ? prefix.length : 0) : newCursor;\n            setCursor(newCursor);\n            setChangeCount(changeCount + 1);\n        }\n        setStateValue(formattedValue);\n        if (onValueChange) {\n            var values = {\n                float: numberValue,\n                formatted: formattedValue,\n                value: stringValue,\n            };\n            onValueChange(stringValue, name, values);\n        }\n    };\n    /**\n     * Handle change event\n     */\n    var handleOnChange = function (event) {\n        var _a = event.target, value = _a.value, selectionStart = _a.selectionStart;\n        processChange(value, selectionStart);\n        onChange && onChange(event);\n    };\n    /**\n     * Handle focus event\n     */\n    var handleOnFocus = function (event) {\n        onFocus && onFocus(event);\n        return stateValue ? stateValue.length : 0;\n    };\n    /**\n     * Handle blur event\n     *\n     * Format value by padding/trimming decimals if required by\n     */\n    var handleOnBlur = function (event) {\n        var value = event.target.value;\n        var valueOnly = cleanValue(__assign({ value: value }, cleanValueOptions));\n        if (valueOnly === '-' || valueOnly === decimalSeparator || !valueOnly) {\n            setStateValue('');\n            onBlur && onBlur(event);\n            return;\n        }\n        var fixedDecimals = fixedDecimalValue(valueOnly, decimalSeparator, fixedDecimalLength);\n        var newValue = padTrimValue(fixedDecimals, decimalSeparator, decimalScale !== undefined ? decimalScale : fixedDecimalLength);\n        var numberValue = parseFloat(newValue.replace(decimalSeparator, '.'));\n        var formattedValue = formatValue(__assign(__assign({}, formatValueOptions), { value: newValue }));\n        if (onValueChange && formatValueOnBlur) {\n            onValueChange(newValue, name, {\n                float: numberValue,\n                formatted: formattedValue,\n                value: newValue,\n            });\n        }\n        setStateValue(formattedValue);\n        onBlur && onBlur(event);\n    };\n    /**\n     * Handle key down event\n     *\n     * Increase or decrease value by step\n     */\n    var handleOnKeyDown = function (event) {\n        var key = event.key;\n        setLastKeyStroke(key);\n        if (step && (key === 'ArrowUp' || key === 'ArrowDown')) {\n            event.preventDefault();\n            setCursor(stateValue.length);\n            var currentValue = parseFloat(userValue != null\n                ? String(userValue).replace(decimalSeparator, '.')\n                : cleanValue(__assign({ value: stateValue }, cleanValueOptions))) || 0;\n            var newValue = key === 'ArrowUp' ? currentValue + step : currentValue - step;\n            if (min !== undefined && newValue < Number(min)) {\n                return;\n            }\n            if (max !== undefined && newValue > Number(max)) {\n                return;\n            }\n            var fixedLength = String(step).includes('.')\n                ? Number(String(step).split('.')[1].length)\n                : undefined;\n            processChange(String(fixedLength ? newValue.toFixed(fixedLength) : newValue).replace('.', decimalSeparator));\n        }\n        onKeyDown && onKeyDown(event);\n    };\n    /**\n     * Handle key up event\n     *\n     * Move cursor if there is a suffix to prevent user typing past suffix\n     */\n    var handleOnKeyUp = function (event) {\n        var key = event.key, selectionStart = event.currentTarget.selectionStart;\n        if (key !== 'ArrowUp' && key !== 'ArrowDown' && stateValue !== '-') {\n            var suffix_1 = getSuffix(stateValue, { groupSeparator: groupSeparator, decimalSeparator: decimalSeparator });\n            if (suffix_1 && selectionStart && selectionStart > stateValue.length - suffix_1.length) {\n                /* istanbul ignore else */\n                if (inputRef.current) {\n                    var newCursor = stateValue.length - suffix_1.length;\n                    inputRef.current.setSelectionRange(newCursor, newCursor);\n                }\n            }\n        }\n        onKeyUp && onKeyUp(event);\n    };\n    // Update state if userValue changes to undefined\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n        if (userValue == null && defaultValue == null) {\n            setStateValue('');\n        }\n    }, [defaultValue, userValue]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n        // prevent cursor jumping if editing value\n        if (dirty &&\n            stateValue !== '-' &&\n            inputRef.current &&\n            document.activeElement === inputRef.current) {\n            inputRef.current.setSelectionRange(cursor, cursor);\n        }\n    }, [stateValue, cursor, inputRef, dirty, changeCount]);\n    /**\n     * If user has only entered \"-\" or decimal separator,\n     * keep the char to allow them to enter next value\n     */\n    var getRenderValue = function () {\n        if (userValue != null &&\n            stateValue !== '-' &&\n            (!decimalSeparator || stateValue !== decimalSeparator)) {\n            return formatValue(__assign(__assign({}, formatValueOptions), { decimalScale: dirty ? undefined : decimalScale, value: String(userValue) }));\n        }\n        return stateValue;\n    };\n    var inputProps = __assign({ type: 'text', inputMode: 'decimal', id: id, name: name, className: className, onChange: handleOnChange, onBlur: handleOnBlur, onFocus: handleOnFocus, onKeyDown: handleOnKeyDown, onKeyUp: handleOnKeyUp, placeholder: placeholder, disabled: disabled, value: getRenderValue(), ref: inputRef }, props);\n    if (customInput) {\n        var CustomInput = customInput;\n        return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(CustomInput, __assign({}, inputProps));\n    }\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", __assign({}, inputProps));\n});\nCurrencyInput.displayName = 'CurrencyInput';\n\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtY3VycmVuY3ktaW5wdXQtZmllbGQvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBcUc7O0FBRXJHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRSxPQUFPO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseWtCQUF5a0IsbUJBQW1CO0FBQzVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvRkFBb0Y7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQSxlQUFlLDBEQUFtQix5QkFBeUI7QUFDM0Q7QUFDQSxXQUFXLDBEQUFtQixxQkFBcUI7QUFDbkQsQ0FBQztBQUNEOztBQUU2RDtBQUM3RCIsInNvdXJjZXMiOlsid2VicGFjazovL21lZHVzYS1uZXh0Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LWN1cnJlbmN5LWlucHV0LWZpZWxkL2Rpc3QvaW5kZXguZXNtLmpzPzRjMmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IGZvcndhcmRSZWYsIHVzZU1lbW8sIHVzZVN0YXRlLCB1c2VSZWYsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0O1xuICB9O1xuICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgdFtwXSA9IHNbcF07XG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgfVxuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgfVxuICB9XG4gIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufVxuXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XG59O1xuXG4vKipcbiAqIEVzY2FwZSByZWdleCBjaGFyXG4gKlxuICogU2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNzg4NTg1NS91c2UtZHluYW1pYy12YXJpYWJsZS1zdHJpbmctYXMtcmVnZXgtcGF0dGVybi1pbi1qYXZhc2NyaXB0XG4gKi9cbnZhciBlc2NhcGVSZWdFeHAgPSBmdW5jdGlvbiAoc3RyaW5nVG9Hb0ludG9UaGVSZWdleCkge1xuICAgIHJldHVybiBzdHJpbmdUb0dvSW50b1RoZVJlZ2V4LnJlcGxhY2UoL1stL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbn07XG5cbnZhciBhYmJyTWFwID0geyBrOiAxMDAwLCBtOiAxMDAwMDAwLCBiOiAxMDAwMDAwMDAwIH07XG4vKipcbiAqIFBhcnNlIGEgdmFsdWUgd2l0aCBhYmJyZXZpYXRpb24gZS5nIDFrID0gMTAwMFxuICovXG52YXIgcGFyc2VBYmJyVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGRlY2ltYWxTZXBhcmF0b3IpIHtcbiAgICBpZiAoZGVjaW1hbFNlcGFyYXRvciA9PT0gdm9pZCAwKSB7IGRlY2ltYWxTZXBhcmF0b3IgPSAnLic7IH1cbiAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cChcIihcXFxcZCsoXCIuY29uY2F0KGVzY2FwZVJlZ0V4cChkZWNpbWFsU2VwYXJhdG9yKSwgXCJcXFxcZCopPykoW2ttYl0pJFwiKSwgJ2knKTtcbiAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaChyZWcpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgZGlnaXRzID0gbWF0Y2hbMV0sIGFiYnIgPSBtYXRjaFszXTtcbiAgICAgICAgdmFyIG11bHRpcGxpZXIgPSBhYmJyTWFwW2FiYnIudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIHJldHVybiBOdW1iZXIoZGlnaXRzLnJlcGxhY2UoZGVjaW1hbFNlcGFyYXRvciwgJy4nKSkgKiBtdWx0aXBsaWVyO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgZ3JvdXAgc2VwYXJhdG9yIGZyb20gdmFsdWUgZWcuIDEsMDAwID4gMTAwMFxuICovXG52YXIgcmVtb3ZlU2VwYXJhdG9ycyA9IGZ1bmN0aW9uICh2YWx1ZSwgc2VwYXJhdG9yKSB7XG4gICAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwKSB7IHNlcGFyYXRvciA9ICcsJzsgfVxuICAgIHZhciByZWcgPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cChzZXBhcmF0b3IpLCAnZycpO1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlZywgJycpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgaW52YWxpZCBjaGFyYWN0ZXJzXG4gKi9cbnZhciByZW1vdmVJbnZhbGlkQ2hhcnMgPSBmdW5jdGlvbiAodmFsdWUsIHZhbGlkQ2hhcnMpIHtcbiAgICB2YXIgY2hhcnMgPSBlc2NhcGVSZWdFeHAodmFsaWRDaGFycy5qb2luKCcnKSk7XG4gICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoXCJbXlxcXFxkXCIuY29uY2F0KGNoYXJzLCBcIl1cIiksICdnaScpO1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlZywgJycpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgcHJlZml4LCBzZXBhcmF0b3JzIGFuZCBleHRyYSBkZWNpbWFscyBmcm9tIHZhbHVlXG4gKi9cbnZhciBjbGVhblZhbHVlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHZhbHVlID0gX2EudmFsdWUsIF9iID0gX2EuZ3JvdXBTZXBhcmF0b3IsIGdyb3VwU2VwYXJhdG9yID0gX2IgPT09IHZvaWQgMCA/ICcsJyA6IF9iLCBfYyA9IF9hLmRlY2ltYWxTZXBhcmF0b3IsIGRlY2ltYWxTZXBhcmF0b3IgPSBfYyA9PT0gdm9pZCAwID8gJy4nIDogX2MsIF9kID0gX2EuYWxsb3dEZWNpbWFscywgYWxsb3dEZWNpbWFscyA9IF9kID09PSB2b2lkIDAgPyB0cnVlIDogX2QsIF9lID0gX2EuZGVjaW1hbHNMaW1pdCwgZGVjaW1hbHNMaW1pdCA9IF9lID09PSB2b2lkIDAgPyAyIDogX2UsIF9mID0gX2EuYWxsb3dOZWdhdGl2ZVZhbHVlLCBhbGxvd05lZ2F0aXZlVmFsdWUgPSBfZiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9mLCBfZyA9IF9hLmRpc2FibGVBYmJyZXZpYXRpb25zLCBkaXNhYmxlQWJicmV2aWF0aW9ucyA9IF9nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9nLCBfaCA9IF9hLnByZWZpeCwgcHJlZml4ID0gX2ggPT09IHZvaWQgMCA/ICcnIDogX2gsIF9qID0gX2EudHJhbnNmb3JtUmF3VmFsdWUsIHRyYW5zZm9ybVJhd1ZhbHVlID0gX2ogPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChyYXdWYWx1ZSkgeyByZXR1cm4gcmF3VmFsdWU7IH0gOiBfajtcbiAgICB2YXIgdHJhbnNmb3JtZWRWYWx1ZSA9IHRyYW5zZm9ybVJhd1ZhbHVlKHZhbHVlKTtcbiAgICBpZiAodHJhbnNmb3JtZWRWYWx1ZSA9PT0gJy0nKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFZhbHVlO1xuICAgIH1cbiAgICB2YXIgYWJicmV2aWF0aW9ucyA9IGRpc2FibGVBYmJyZXZpYXRpb25zID8gW10gOiBbJ2snLCAnbScsICdiJ107XG4gICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoXCIoKF58XFxcXEQpLVxcXFxkKXwoLVwiLmNvbmNhdChlc2NhcGVSZWdFeHAocHJlZml4KSwgXCIpXCIpKTtcbiAgICB2YXIgaXNOZWdhdGl2ZSA9IHJlZy50ZXN0KHRyYW5zZm9ybWVkVmFsdWUpO1xuICAgIC8vIElzIHRoZXJlIGEgZGlnaXQgYmVmb3JlIHRoZSBwcmVmaXg/IGVnLiAxJFxuICAgIHZhciBfayA9IFJlZ0V4cChcIihcXFxcZCspLT9cIi5jb25jYXQoZXNjYXBlUmVnRXhwKHByZWZpeCkpKS5leGVjKHZhbHVlKSB8fCBbXSwgcHJlZml4V2l0aFZhbHVlID0gX2tbMF0sIHByZVZhbHVlID0gX2tbMV07XG4gICAgdmFyIHdpdGhvdXRQcmVmaXggPSBwcmVmaXhcbiAgICAgICAgPyBwcmVmaXhXaXRoVmFsdWVcbiAgICAgICAgICAgID8gdHJhbnNmb3JtZWRWYWx1ZS5yZXBsYWNlKHByZWZpeFdpdGhWYWx1ZSwgJycpLmNvbmNhdChwcmVWYWx1ZSlcbiAgICAgICAgICAgIDogdHJhbnNmb3JtZWRWYWx1ZS5yZXBsYWNlKHByZWZpeCwgJycpXG4gICAgICAgIDogdHJhbnNmb3JtZWRWYWx1ZTtcbiAgICB2YXIgd2l0aG91dFNlcGFyYXRvcnMgPSByZW1vdmVTZXBhcmF0b3JzKHdpdGhvdXRQcmVmaXgsIGdyb3VwU2VwYXJhdG9yKTtcbiAgICB2YXIgd2l0aG91dEludmFsaWRDaGFycyA9IHJlbW92ZUludmFsaWRDaGFycyh3aXRob3V0U2VwYXJhdG9ycywgX19zcHJlYWRBcnJheShbXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yLFxuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yXG4gICAgXSwgYWJicmV2aWF0aW9ucywgdHJ1ZSkpO1xuICAgIHZhciB2YWx1ZU9ubHkgPSB3aXRob3V0SW52YWxpZENoYXJzO1xuICAgIGlmICghZGlzYWJsZUFiYnJldmlhdGlvbnMpIHtcbiAgICAgICAgLy8gZGlzYWxsb3cgbGV0dGVyIHdpdGhvdXQgbnVtYmVyXG4gICAgICAgIGlmIChhYmJyZXZpYXRpb25zLnNvbWUoZnVuY3Rpb24gKGxldHRlcikgeyByZXR1cm4gbGV0dGVyID09PSB3aXRob3V0SW52YWxpZENoYXJzLnRvTG93ZXJDYXNlKCkucmVwbGFjZShkZWNpbWFsU2VwYXJhdG9yLCAnJyk7IH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlQWJiclZhbHVlKHdpdGhvdXRJbnZhbGlkQ2hhcnMsIGRlY2ltYWxTZXBhcmF0b3IpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICB2YWx1ZU9ubHkgPSBTdHJpbmcocGFyc2VkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW5jbHVkZU5lZ2F0aXZlID0gaXNOZWdhdGl2ZSAmJiBhbGxvd05lZ2F0aXZlVmFsdWUgPyAnLScgOiAnJztcbiAgICBpZiAoZGVjaW1hbFNlcGFyYXRvciAmJiB2YWx1ZU9ubHkuaW5jbHVkZXMoZGVjaW1hbFNlcGFyYXRvcikpIHtcbiAgICAgICAgdmFyIF9sID0gd2l0aG91dEludmFsaWRDaGFycy5zcGxpdChkZWNpbWFsU2VwYXJhdG9yKSwgaW50ID0gX2xbMF0sIGRlY2ltYWxzID0gX2xbMV07XG4gICAgICAgIHZhciB0cmltbWVkRGVjaW1hbHMgPSBkZWNpbWFsc0xpbWl0ICYmIGRlY2ltYWxzID8gZGVjaW1hbHMuc2xpY2UoMCwgZGVjaW1hbHNMaW1pdCkgOiBkZWNpbWFscztcbiAgICAgICAgdmFyIGluY2x1ZGVEZWNpbWFscyA9IGFsbG93RGVjaW1hbHMgPyBcIlwiLmNvbmNhdChkZWNpbWFsU2VwYXJhdG9yKS5jb25jYXQodHJpbW1lZERlY2ltYWxzKSA6ICcnO1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoaW5jbHVkZU5lZ2F0aXZlKS5jb25jYXQoaW50KS5jb25jYXQoaW5jbHVkZURlY2ltYWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGluY2x1ZGVOZWdhdGl2ZSkuY29uY2F0KHZhbHVlT25seSk7XG59O1xuXG52YXIgZml4ZWREZWNpbWFsVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGRlY2ltYWxTZXBhcmF0b3IsIGZpeGVkRGVjaW1hbExlbmd0aCkge1xuICAgIGlmIChmaXhlZERlY2ltYWxMZW5ndGggIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmIChmaXhlZERlY2ltYWxMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKGRlY2ltYWxTZXBhcmF0b3IsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoZGVjaW1hbFNlcGFyYXRvcikpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHZhbHVlLnNwbGl0KGRlY2ltYWxTZXBhcmF0b3IpLCBpbnQgPSBfYVswXSwgZGVjaW1hbHMgPSBfYVsxXTtcbiAgICAgICAgICAgIGlmIChkZWNpbWFscy5sZW5ndGggPT09IGZpeGVkRGVjaW1hbExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWNpbWFscy5sZW5ndGggPiBmaXhlZERlY2ltYWxMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoaW50KS5jb25jYXQoZGVjaW1hbFNlcGFyYXRvcikuY29uY2F0KGRlY2ltYWxzLnNsaWNlKDAsIGZpeGVkRGVjaW1hbExlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZWcgPSB2YWx1ZS5sZW5ndGggPiBmaXhlZERlY2ltYWxMZW5ndGhcbiAgICAgICAgICAgID8gbmV3IFJlZ0V4cChcIihcXFxcZCspKFxcXFxke1wiLmNvbmNhdChmaXhlZERlY2ltYWxMZW5ndGgsIFwifSlcIikpXG4gICAgICAgICAgICA6IG5ldyBSZWdFeHAoXCIoXFxcXGQpKFxcXFxkKylcIik7XG4gICAgICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKHJlZyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIGludCA9IG1hdGNoWzFdLCBkZWNpbWFscyA9IG1hdGNoWzJdO1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGludCkuY29uY2F0KGRlY2ltYWxTZXBhcmF0b3IpLmNvbmNhdChkZWNpbWFscyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIGdldFN1ZmZpeCA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYS5ncm91cFNlcGFyYXRvciwgZ3JvdXBTZXBhcmF0b3IgPSBfYiA9PT0gdm9pZCAwID8gJywnIDogX2IsIF9jID0gX2EuZGVjaW1hbFNlcGFyYXRvciwgZGVjaW1hbFNlcGFyYXRvciA9IF9jID09PSB2b2lkIDAgPyAnLicgOiBfYztcbiAgICB2YXIgc3VmZml4UmVnID0gbmV3IFJlZ0V4cChcIlxcXFxkKFteXCIuY29uY2F0KGVzY2FwZVJlZ0V4cChncm91cFNlcGFyYXRvcikpLmNvbmNhdChlc2NhcGVSZWdFeHAoZGVjaW1hbFNlcGFyYXRvciksIFwiMC05XSspXCIpKTtcbiAgICB2YXIgc3VmZml4TWF0Y2ggPSB2YWx1ZS5tYXRjaChzdWZmaXhSZWcpO1xuICAgIHJldHVybiBzdWZmaXhNYXRjaCA/IHN1ZmZpeE1hdGNoWzFdIDogdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBGb3JtYXQgdmFsdWUgd2l0aCBkZWNpbWFsIHNlcGFyYXRvciwgZ3JvdXAgc2VwYXJhdG9yIGFuZCBwcmVmaXhcbiAqL1xudmFyIGZvcm1hdFZhbHVlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgX3ZhbHVlID0gb3B0aW9ucy52YWx1ZSwgZGVjaW1hbFNlcGFyYXRvciA9IG9wdGlvbnMuZGVjaW1hbFNlcGFyYXRvciwgaW50bENvbmZpZyA9IG9wdGlvbnMuaW50bENvbmZpZywgZGVjaW1hbFNjYWxlID0gb3B0aW9ucy5kZWNpbWFsU2NhbGUsIF9hID0gb3B0aW9ucy5wcmVmaXgsIHByZWZpeCA9IF9hID09PSB2b2lkIDAgPyAnJyA6IF9hLCBfYiA9IG9wdGlvbnMuc3VmZml4LCBzdWZmaXggPSBfYiA9PT0gdm9pZCAwID8gJycgOiBfYjtcbiAgICBpZiAoX3ZhbHVlID09PSAnJyB8fCBfdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmIChfdmFsdWUgPT09ICctJykge1xuICAgICAgICByZXR1cm4gJy0nO1xuICAgIH1cbiAgICB2YXIgaXNOZWdhdGl2ZSA9IG5ldyBSZWdFeHAoXCJeXFxcXGQ/LVwiLmNvbmNhdChwcmVmaXggPyBcIlwiLmNvbmNhdChlc2NhcGVSZWdFeHAocHJlZml4KSwgXCI/XCIpIDogJycsIFwiXFxcXGRcIikpLnRlc3QoX3ZhbHVlKTtcbiAgICB2YXIgdmFsdWUgPSBkZWNpbWFsU2VwYXJhdG9yICE9PSAnLidcbiAgICAgICAgPyByZXBsYWNlRGVjaW1hbFNlcGFyYXRvcihfdmFsdWUsIGRlY2ltYWxTZXBhcmF0b3IsIGlzTmVnYXRpdmUpXG4gICAgICAgIDogX3ZhbHVlO1xuICAgIGlmIChkZWNpbWFsU2VwYXJhdG9yICYmIGRlY2ltYWxTZXBhcmF0b3IgIT09ICctJyAmJiB2YWx1ZS5zdGFydHNXaXRoKGRlY2ltYWxTZXBhcmF0b3IpKSB7XG4gICAgICAgIHZhbHVlID0gJzAnICsgdmFsdWU7XG4gICAgfVxuICAgIHZhciBkZWZhdWx0TnVtYmVyRm9ybWF0T3B0aW9ucyA9IHtcbiAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBkZWNpbWFsU2NhbGUgfHwgMCxcbiAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAyMCxcbiAgICB9O1xuICAgIHZhciBudW1iZXJGb3JtYXR0ZXIgPSBpbnRsQ29uZmlnXG4gICAgICAgID8gbmV3IEludGwuTnVtYmVyRm9ybWF0KGludGxDb25maWcubG9jYWxlLCBpbnRsQ29uZmlnLmN1cnJlbmN5XG4gICAgICAgICAgICA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0TnVtYmVyRm9ybWF0T3B0aW9ucyksIHsgc3R5bGU6ICdjdXJyZW5jeScsIGN1cnJlbmN5OiBpbnRsQ29uZmlnLmN1cnJlbmN5IH0pIDogZGVmYXVsdE51bWJlckZvcm1hdE9wdGlvbnMpXG4gICAgICAgIDogbmV3IEludGwuTnVtYmVyRm9ybWF0KHVuZGVmaW5lZCwgZGVmYXVsdE51bWJlckZvcm1hdE9wdGlvbnMpO1xuICAgIHZhciBwYXJ0cyA9IG51bWJlckZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKE51bWJlcih2YWx1ZSkpO1xuICAgIHZhciBmb3JtYXR0ZWQgPSByZXBsYWNlUGFydHMocGFydHMsIG9wdGlvbnMpO1xuICAgIC8vIERvZXMgaW50bCBmb3JtYXR0aW5nIGFkZCBhIHN1ZmZpeD9cbiAgICB2YXIgaW50bFN1ZmZpeCA9IGdldFN1ZmZpeChmb3JtYXR0ZWQsIF9fYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gICAgLy8gSW5jbHVkZSBkZWNpbWFsIHNlcGFyYXRvciBpZiB1c2VyIGlucHV0IGVuZHMgd2l0aCBkZWNpbWFsIHNlcGFyYXRvclxuICAgIHZhciBpbmNsdWRlRGVjaW1hbFNlcGFyYXRvciA9IF92YWx1ZS5zbGljZSgtMSkgPT09IGRlY2ltYWxTZXBhcmF0b3IgPyBkZWNpbWFsU2VwYXJhdG9yIDogJyc7XG4gICAgdmFyIF9jID0gdmFsdWUubWF0Y2goUmVnRXhwKCdcXFxcZCtcXFxcLihcXFxcZCspJykpIHx8IFtdLCBkZWNpbWFscyA9IF9jWzFdO1xuICAgIC8vIEtlZXAgb3JpZ2luYWwgZGVjaW1hbCBwYWRkaW5nIGlmIG5vIGRlY2ltYWxTY2FsZVxuICAgIGlmIChkZWNpbWFsU2NhbGUgPT09IHVuZGVmaW5lZCAmJiBkZWNpbWFscyAmJiBkZWNpbWFsU2VwYXJhdG9yKSB7XG4gICAgICAgIGlmIChmb3JtYXR0ZWQuaW5jbHVkZXMoZGVjaW1hbFNlcGFyYXRvcikpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC5yZXBsYWNlKFJlZ0V4cChcIihcXFxcZCspKFwiLmNvbmNhdChlc2NhcGVSZWdFeHAoZGVjaW1hbFNlcGFyYXRvciksIFwiKShcXFxcZCspXCIpLCAnZycpLCBcIiQxJDJcIi5jb25jYXQoZGVjaW1hbHMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbnRsU3VmZml4ICYmICFzdWZmaXgpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWQgPSBmb3JtYXR0ZWQucmVwbGFjZShpbnRsU3VmZml4LCBcIlwiLmNvbmNhdChkZWNpbWFsU2VwYXJhdG9yKS5jb25jYXQoZGVjaW1hbHMpLmNvbmNhdChpbnRsU3VmZml4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWQgPSBcIlwiLmNvbmNhdChmb3JtYXR0ZWQpLmNvbmNhdChkZWNpbWFsU2VwYXJhdG9yKS5jb25jYXQoZGVjaW1hbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdWZmaXggJiYgaW5jbHVkZURlY2ltYWxTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGZvcm1hdHRlZCkuY29uY2F0KGluY2x1ZGVEZWNpbWFsU2VwYXJhdG9yKS5jb25jYXQoc3VmZml4KTtcbiAgICB9XG4gICAgaWYgKGludGxTdWZmaXggJiYgaW5jbHVkZURlY2ltYWxTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZC5yZXBsYWNlKGludGxTdWZmaXgsIFwiXCIuY29uY2F0KGluY2x1ZGVEZWNpbWFsU2VwYXJhdG9yKS5jb25jYXQoaW50bFN1ZmZpeCkpO1xuICAgIH1cbiAgICBpZiAoaW50bFN1ZmZpeCAmJiBzdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZC5yZXBsYWNlKGludGxTdWZmaXgsIFwiXCIuY29uY2F0KGluY2x1ZGVEZWNpbWFsU2VwYXJhdG9yKS5jb25jYXQoc3VmZml4KSk7XG4gICAgfVxuICAgIHJldHVybiBbZm9ybWF0dGVkLCBpbmNsdWRlRGVjaW1hbFNlcGFyYXRvciwgc3VmZml4XS5qb2luKCcnKTtcbn07XG4vKipcbiAqIEJlZm9yZSBjb252ZXJ0aW5nIHRvIE51bWJlciwgZGVjaW1hbCBzZXBhcmF0b3IgaGFzIHRvIGJlIC5cbiAqL1xudmFyIHJlcGxhY2VEZWNpbWFsU2VwYXJhdG9yID0gZnVuY3Rpb24gKHZhbHVlLCBkZWNpbWFsU2VwYXJhdG9yLCBpc05lZ2F0aXZlKSB7XG4gICAgdmFyIG5ld1ZhbHVlID0gdmFsdWU7XG4gICAgaWYgKGRlY2ltYWxTZXBhcmF0b3IgJiYgZGVjaW1hbFNlcGFyYXRvciAhPT0gJy4nKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUucmVwbGFjZShSZWdFeHAoZXNjYXBlUmVnRXhwKGRlY2ltYWxTZXBhcmF0b3IpLCAnZycpLCAnLicpO1xuICAgICAgICBpZiAoaXNOZWdhdGl2ZSAmJiBkZWNpbWFsU2VwYXJhdG9yID09PSAnLScpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gXCItXCIuY29uY2F0KG5ld1ZhbHVlLnNsaWNlKDEpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3VmFsdWU7XG59O1xudmFyIHJlcGxhY2VQYXJ0cyA9IGZ1bmN0aW9uIChwYXJ0cywgX2EpIHtcbiAgICB2YXIgcHJlZml4ID0gX2EucHJlZml4LCBncm91cFNlcGFyYXRvciA9IF9hLmdyb3VwU2VwYXJhdG9yLCBkZWNpbWFsU2VwYXJhdG9yID0gX2EuZGVjaW1hbFNlcGFyYXRvciwgZGVjaW1hbFNjYWxlID0gX2EuZGVjaW1hbFNjYWxlLCBfYiA9IF9hLmRpc2FibGVHcm91cFNlcGFyYXRvcnMsIGRpc2FibGVHcm91cFNlcGFyYXRvcnMgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYjtcbiAgICByZXR1cm4gcGFydHNcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAocHJldiwgX2EsIGkpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICBpZiAoaSA9PT0gMCAmJiBwcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbWludXNTaWduJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbdmFsdWUsIHByZWZpeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2N1cnJlbmN5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHByZXYsIHRydWUpLCBbcHJlZml4XSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtwcmVmaXgsIHZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2N1cnJlbmN5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCA/IHByZXYgOiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHByZXYsIHRydWUpLCBbdmFsdWVdLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgICAgIHJldHVybiAhZGlzYWJsZUdyb3VwU2VwYXJhdG9yc1xuICAgICAgICAgICAgICAgID8gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBwcmV2LCB0cnVlKSwgW2dyb3VwU2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBncm91cFNlcGFyYXRvciA6IHZhbHVlXSwgZmFsc2UpIDogcHJldjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RlY2ltYWwnKSB7XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFNjYWxlICE9PSB1bmRlZmluZWQgJiYgZGVjaW1hbFNjYWxlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBwcmV2LCB0cnVlKSwgW2RlY2ltYWxTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IGRlY2ltYWxTZXBhcmF0b3IgOiB2YWx1ZV0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2ZyYWN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgcHJldiwgdHJ1ZSksIFtkZWNpbWFsU2NhbGUgIT09IHVuZGVmaW5lZCA/IHZhbHVlLnNsaWNlKDAsIGRlY2ltYWxTY2FsZSkgOiB2YWx1ZV0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBwcmV2LCB0cnVlKSwgW3ZhbHVlXSwgZmFsc2UpO1xuICAgIH0sIFsnJ10pXG4gICAgICAgIC5qb2luKCcnKTtcbn07XG5cbnZhciBkZWZhdWx0Q29uZmlnID0ge1xuICAgIGN1cnJlbmN5U3ltYm9sOiAnJyxcbiAgICBncm91cFNlcGFyYXRvcjogJycsXG4gICAgZGVjaW1hbFNlcGFyYXRvcjogJycsXG4gICAgcHJlZml4OiAnJyxcbiAgICBzdWZmaXg6ICcnLFxufTtcbi8qKlxuICogR2V0IGxvY2FsZSBjb25maWcgZnJvbSBpbnB1dCBvciBkZWZhdWx0XG4gKi9cbnZhciBnZXRMb2NhbGVDb25maWcgPSBmdW5jdGlvbiAoaW50bENvbmZpZykge1xuICAgIHZhciBfYSA9IGludGxDb25maWcgfHwge30sIGxvY2FsZSA9IF9hLmxvY2FsZSwgY3VycmVuY3kgPSBfYS5jdXJyZW5jeTtcbiAgICB2YXIgbnVtYmVyRm9ybWF0dGVyID0gbG9jYWxlXG4gICAgICAgID8gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgY3VycmVuY3kgPyB7IGN1cnJlbmN5OiBjdXJyZW5jeSwgc3R5bGU6ICdjdXJyZW5jeScgfSA6IHVuZGVmaW5lZClcbiAgICAgICAgOiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoKTtcbiAgICByZXR1cm4gbnVtYmVyRm9ybWF0dGVyLmZvcm1hdFRvUGFydHMoMTAwMC4xKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIsIGkpIHtcbiAgICAgICAgaWYgKGN1cnIudHlwZSA9PT0gJ2N1cnJlbmN5Jykge1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXYpLCB7IGN1cnJlbmN5U3ltYm9sOiBjdXJyLnZhbHVlLCBwcmVmaXg6IGN1cnIudmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXYpLCB7IGN1cnJlbmN5U3ltYm9sOiBjdXJyLnZhbHVlLCBzdWZmaXg6IGN1cnIudmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnIudHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2KSwgeyBncm91cFNlcGFyYXRvcjogY3Vyci52YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3Vyci50eXBlID09PSAnZGVjaW1hbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldiksIHsgZGVjaW1hbFNlcGFyYXRvcjogY3Vyci52YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldjtcbiAgICB9LCBkZWZhdWx0Q29uZmlnKTtcbn07XG5cbnZhciBpc051bWJlciA9IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gUmVnRXhwKC9cXGQvLCAnZ2knKS50ZXN0KGlucHV0KTsgfTtcblxudmFyIHBhZFRyaW1WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVjaW1hbFNlcGFyYXRvciwgZGVjaW1hbFNjYWxlKSB7XG4gICAgaWYgKGRlY2ltYWxTZXBhcmF0b3IgPT09IHZvaWQgMCkgeyBkZWNpbWFsU2VwYXJhdG9yID0gJy4nOyB9XG4gICAgaWYgKGRlY2ltYWxTY2FsZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZS5tYXRjaCgvXFxkL2cpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIF9hID0gdmFsdWUuc3BsaXQoZGVjaW1hbFNlcGFyYXRvciksIGludCA9IF9hWzBdLCBkZWNpbWFscyA9IF9hWzFdO1xuICAgIGlmIChkZWNpbWFsU2NhbGUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGludDtcbiAgICB9XG4gICAgdmFyIG5ld1ZhbHVlID0gZGVjaW1hbHMgfHwgJyc7XG4gICAgaWYgKG5ld1ZhbHVlLmxlbmd0aCA8IGRlY2ltYWxTY2FsZSkge1xuICAgICAgICB3aGlsZSAobmV3VmFsdWUubGVuZ3RoIDwgZGVjaW1hbFNjYWxlKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSArPSAnMCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUuc2xpY2UoMCwgZGVjaW1hbFNjYWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGludCkuY29uY2F0KGRlY2ltYWxTZXBhcmF0b3IpLmNvbmNhdChuZXdWYWx1ZSk7XG59O1xuXG4vKipcbiAqIEJhc2VkIG9uIHRoZSBsYXN0IGtleSBzdHJva2UgYW5kIHRoZSBjdXJzb3IgcG9zaXRpb24sIHVwZGF0ZSB0aGUgdmFsdWVcbiAqIGFuZCByZXBvc2l0aW9uIHRoZSBjdXJzb3IgdG8gdGhlIHJpZ2h0IHBsYWNlXG4gKi9cbnZhciByZXBvc2l0aW9uQ3Vyc29yID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gX2Euc2VsZWN0aW9uU3RhcnQsIHZhbHVlID0gX2EudmFsdWUsIGxhc3RLZXlTdHJva2UgPSBfYS5sYXN0S2V5U3Ryb2tlLCBzdGF0ZVZhbHVlID0gX2Euc3RhdGVWYWx1ZSwgZ3JvdXBTZXBhcmF0b3IgPSBfYS5ncm91cFNlcGFyYXRvcjtcbiAgICB2YXIgY3Vyc29yUG9zaXRpb24gPSBzZWxlY3Rpb25TdGFydDtcbiAgICB2YXIgbW9kaWZpZWRWYWx1ZSA9IHZhbHVlO1xuICAgIGlmIChzdGF0ZVZhbHVlICYmIGN1cnNvclBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBzcGxpdFZhbHVlID0gdmFsdWUuc3BsaXQoJycpO1xuICAgICAgICAvLyBpZiBjdXJzb3IgaXMgdG8gcmlnaHQgb2YgZ3JvdXBTZXBhcmF0b3IgYW5kIGJhY2tzcGFjZSBwcmVzc2VkLCBkZWxldGUgdGhlIGNoYXJhY3RlciB0byB0aGUgbGVmdCBvZiB0aGUgc2VwYXJhdG9yIGFuZCByZXBvc2l0aW9uIHRoZSBjdXJzb3JcbiAgICAgICAgaWYgKGxhc3RLZXlTdHJva2UgPT09ICdCYWNrc3BhY2UnICYmIHN0YXRlVmFsdWVbY3Vyc29yUG9zaXRpb25dID09PSBncm91cFNlcGFyYXRvcikge1xuICAgICAgICAgICAgc3BsaXRWYWx1ZS5zcGxpY2UoY3Vyc29yUG9zaXRpb24gLSAxLCAxKTtcbiAgICAgICAgICAgIGN1cnNvclBvc2l0aW9uIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgY3Vyc29yIGlzIHRvIGxlZnQgb2YgZ3JvdXBTZXBhcmF0b3IgYW5kIGRlbGV0ZSBwcmVzc2VkLCBkZWxldGUgdGhlIGNoYXJhY3RlciB0byB0aGUgcmlnaHQgb2YgdGhlIHNlcGFyYXRvciBhbmQgcmVwb3NpdGlvbiB0aGUgY3Vyc29yXG4gICAgICAgIGlmIChsYXN0S2V5U3Ryb2tlID09PSAnRGVsZXRlJyAmJiBzdGF0ZVZhbHVlW2N1cnNvclBvc2l0aW9uXSA9PT0gZ3JvdXBTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHNwbGl0VmFsdWUuc3BsaWNlKGN1cnNvclBvc2l0aW9uLCAxKTtcbiAgICAgICAgICAgIGN1cnNvclBvc2l0aW9uICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgbW9kaWZpZWRWYWx1ZSA9IHNwbGl0VmFsdWUuam9pbignJyk7XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkVmFsdWU6IG1vZGlmaWVkVmFsdWUsIGN1cnNvclBvc2l0aW9uOiBjdXJzb3JQb3NpdGlvbiB9O1xuICAgIH1cbiAgICByZXR1cm4geyBtb2RpZmllZFZhbHVlOiBtb2RpZmllZFZhbHVlLCBjdXJzb3JQb3NpdGlvbjogc2VsZWN0aW9uU3RhcnQgfTtcbn07XG5cbnZhciBDdXJyZW5jeUlucHV0ID0gZm9yd2FyZFJlZihmdW5jdGlvbiAoX2EsIHJlZikge1xuICAgIHZhciBfYiA9IF9hLmFsbG93RGVjaW1hbHMsIGFsbG93RGVjaW1hbHMgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBfYyA9IF9hLmFsbG93TmVnYXRpdmVWYWx1ZSwgYWxsb3dOZWdhdGl2ZVZhbHVlID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYywgaWQgPSBfYS5pZCwgbmFtZSA9IF9hLm5hbWUsIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgY3VzdG9tSW5wdXQgPSBfYS5jdXN0b21JbnB1dCwgZGVjaW1hbHNMaW1pdCA9IF9hLmRlY2ltYWxzTGltaXQsIGRlZmF1bHRWYWx1ZSA9IF9hLmRlZmF1bHRWYWx1ZSwgX2QgPSBfYS5kaXNhYmxlZCwgZGlzYWJsZWQgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgdXNlck1heExlbmd0aCA9IF9hLm1heExlbmd0aCwgdXNlclZhbHVlID0gX2EudmFsdWUsIG9uVmFsdWVDaGFuZ2UgPSBfYS5vblZhbHVlQ2hhbmdlLCBmaXhlZERlY2ltYWxMZW5ndGggPSBfYS5maXhlZERlY2ltYWxMZW5ndGgsIHBsYWNlaG9sZGVyID0gX2EucGxhY2Vob2xkZXIsIGRlY2ltYWxTY2FsZSA9IF9hLmRlY2ltYWxTY2FsZSwgcHJlZml4ID0gX2EucHJlZml4LCBzdWZmaXggPSBfYS5zdWZmaXgsIGludGxDb25maWcgPSBfYS5pbnRsQ29uZmlnLCBzdGVwID0gX2Euc3RlcCwgbWluID0gX2EubWluLCBtYXggPSBfYS5tYXgsIF9lID0gX2EuZGlzYWJsZUdyb3VwU2VwYXJhdG9ycywgZGlzYWJsZUdyb3VwU2VwYXJhdG9ycyA9IF9lID09PSB2b2lkIDAgPyBmYWxzZSA6IF9lLCBfZiA9IF9hLmRpc2FibGVBYmJyZXZpYXRpb25zLCBkaXNhYmxlQWJicmV2aWF0aW9ucyA9IF9mID09PSB2b2lkIDAgPyBmYWxzZSA6IF9mLCBfZGVjaW1hbFNlcGFyYXRvciA9IF9hLmRlY2ltYWxTZXBhcmF0b3IsIF9ncm91cFNlcGFyYXRvciA9IF9hLmdyb3VwU2VwYXJhdG9yLCBvbkNoYW5nZSA9IF9hLm9uQ2hhbmdlLCBvbkZvY3VzID0gX2Eub25Gb2N1cywgb25CbHVyID0gX2Eub25CbHVyLCBvbktleURvd24gPSBfYS5vbktleURvd24sIG9uS2V5VXAgPSBfYS5vbktleVVwLCB0cmFuc2Zvcm1SYXdWYWx1ZSA9IF9hLnRyYW5zZm9ybVJhd1ZhbHVlLCBfZyA9IF9hLmZvcm1hdFZhbHVlT25CbHVyLCBmb3JtYXRWYWx1ZU9uQmx1ciA9IF9nID09PSB2b2lkIDAgPyB0cnVlIDogX2csIHByb3BzID0gX19yZXN0KF9hLCBbXCJhbGxvd0RlY2ltYWxzXCIsIFwiYWxsb3dOZWdhdGl2ZVZhbHVlXCIsIFwiaWRcIiwgXCJuYW1lXCIsIFwiY2xhc3NOYW1lXCIsIFwiY3VzdG9tSW5wdXRcIiwgXCJkZWNpbWFsc0xpbWl0XCIsIFwiZGVmYXVsdFZhbHVlXCIsIFwiZGlzYWJsZWRcIiwgXCJtYXhMZW5ndGhcIiwgXCJ2YWx1ZVwiLCBcIm9uVmFsdWVDaGFuZ2VcIiwgXCJmaXhlZERlY2ltYWxMZW5ndGhcIiwgXCJwbGFjZWhvbGRlclwiLCBcImRlY2ltYWxTY2FsZVwiLCBcInByZWZpeFwiLCBcInN1ZmZpeFwiLCBcImludGxDb25maWdcIiwgXCJzdGVwXCIsIFwibWluXCIsIFwibWF4XCIsIFwiZGlzYWJsZUdyb3VwU2VwYXJhdG9yc1wiLCBcImRpc2FibGVBYmJyZXZpYXRpb25zXCIsIFwiZGVjaW1hbFNlcGFyYXRvclwiLCBcImdyb3VwU2VwYXJhdG9yXCIsIFwib25DaGFuZ2VcIiwgXCJvbkZvY3VzXCIsIFwib25CbHVyXCIsIFwib25LZXlEb3duXCIsIFwib25LZXlVcFwiLCBcInRyYW5zZm9ybVJhd1ZhbHVlXCIsIFwiZm9ybWF0VmFsdWVPbkJsdXJcIl0pO1xuICAgIGlmIChfZGVjaW1hbFNlcGFyYXRvciAmJiBpc051bWJlcihfZGVjaW1hbFNlcGFyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZWNpbWFsU2VwYXJhdG9yIGNhbm5vdCBiZSBhIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAoX2dyb3VwU2VwYXJhdG9yICYmIGlzTnVtYmVyKF9ncm91cFNlcGFyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdncm91cFNlcGFyYXRvciBjYW5ub3QgYmUgYSBudW1iZXInKTtcbiAgICB9XG4gICAgdmFyIGxvY2FsZUNvbmZpZyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0TG9jYWxlQ29uZmlnKGludGxDb25maWcpOyB9LCBbaW50bENvbmZpZ10pO1xuICAgIHZhciBkZWNpbWFsU2VwYXJhdG9yID0gX2RlY2ltYWxTZXBhcmF0b3IgfHwgbG9jYWxlQ29uZmlnLmRlY2ltYWxTZXBhcmF0b3IgfHwgJyc7XG4gICAgdmFyIGdyb3VwU2VwYXJhdG9yID0gX2dyb3VwU2VwYXJhdG9yIHx8IGxvY2FsZUNvbmZpZy5ncm91cFNlcGFyYXRvciB8fCAnJztcbiAgICBpZiAoZGVjaW1hbFNlcGFyYXRvciAmJlxuICAgICAgICBncm91cFNlcGFyYXRvciAmJlxuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yID09PSBncm91cFNlcGFyYXRvciAmJlxuICAgICAgICBkaXNhYmxlR3JvdXBTZXBhcmF0b3JzID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY2ltYWxTZXBhcmF0b3IgY2Fubm90IGJlIHRoZSBzYW1lIGFzIGdyb3VwU2VwYXJhdG9yJyk7XG4gICAgfVxuICAgIHZhciBmb3JtYXRWYWx1ZU9wdGlvbnMgPSB7XG4gICAgICAgIGRlY2ltYWxTZXBhcmF0b3I6IGRlY2ltYWxTZXBhcmF0b3IsXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yOiBncm91cFNlcGFyYXRvcixcbiAgICAgICAgZGlzYWJsZUdyb3VwU2VwYXJhdG9yczogZGlzYWJsZUdyb3VwU2VwYXJhdG9ycyxcbiAgICAgICAgaW50bENvbmZpZzogaW50bENvbmZpZyxcbiAgICAgICAgcHJlZml4OiBwcmVmaXggfHwgbG9jYWxlQ29uZmlnLnByZWZpeCxcbiAgICAgICAgc3VmZml4OiBzdWZmaXgsXG4gICAgfTtcbiAgICB2YXIgY2xlYW5WYWx1ZU9wdGlvbnMgPSB7XG4gICAgICAgIGRlY2ltYWxTZXBhcmF0b3I6IGRlY2ltYWxTZXBhcmF0b3IsXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yOiBncm91cFNlcGFyYXRvcixcbiAgICAgICAgYWxsb3dEZWNpbWFsczogYWxsb3dEZWNpbWFscyxcbiAgICAgICAgZGVjaW1hbHNMaW1pdDogZGVjaW1hbHNMaW1pdCB8fCBmaXhlZERlY2ltYWxMZW5ndGggfHwgMixcbiAgICAgICAgYWxsb3dOZWdhdGl2ZVZhbHVlOiBhbGxvd05lZ2F0aXZlVmFsdWUsXG4gICAgICAgIGRpc2FibGVBYmJyZXZpYXRpb25zOiBkaXNhYmxlQWJicmV2aWF0aW9ucyxcbiAgICAgICAgcHJlZml4OiBwcmVmaXggfHwgbG9jYWxlQ29uZmlnLnByZWZpeCxcbiAgICAgICAgdHJhbnNmb3JtUmF3VmFsdWU6IHRyYW5zZm9ybVJhd1ZhbHVlLFxuICAgIH07XG4gICAgdmFyIF9oID0gdXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlICE9IG51bGxcbiAgICAgICAgICAgID8gZm9ybWF0VmFsdWUoX19hc3NpZ24oX19hc3NpZ24oe30sIGZvcm1hdFZhbHVlT3B0aW9ucyksIHsgZGVjaW1hbFNjYWxlOiBkZWNpbWFsU2NhbGUsIHZhbHVlOiBTdHJpbmcoZGVmYXVsdFZhbHVlKSB9KSlcbiAgICAgICAgICAgIDogdXNlclZhbHVlICE9IG51bGxcbiAgICAgICAgICAgICAgICA/IGZvcm1hdFZhbHVlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBmb3JtYXRWYWx1ZU9wdGlvbnMpLCB7IGRlY2ltYWxTY2FsZTogZGVjaW1hbFNjYWxlLCB2YWx1ZTogU3RyaW5nKHVzZXJWYWx1ZSkgfSkpXG4gICAgICAgICAgICAgICAgOiAnJztcbiAgICB9KSwgc3RhdGVWYWx1ZSA9IF9oWzBdLCBzZXRTdGF0ZVZhbHVlID0gX2hbMV07XG4gICAgdmFyIF9qID0gdXNlU3RhdGUoZmFsc2UpLCBkaXJ0eSA9IF9qWzBdLCBzZXREaXJ0eSA9IF9qWzFdO1xuICAgIHZhciBfayA9IHVzZVN0YXRlKDApLCBjdXJzb3IgPSBfa1swXSwgc2V0Q3Vyc29yID0gX2tbMV07XG4gICAgdmFyIF9sID0gdXNlU3RhdGUoMCksIGNoYW5nZUNvdW50ID0gX2xbMF0sIHNldENoYW5nZUNvdW50ID0gX2xbMV07XG4gICAgdmFyIF9tID0gdXNlU3RhdGUobnVsbCksIGxhc3RLZXlTdHJva2UgPSBfbVswXSwgc2V0TGFzdEtleVN0cm9rZSA9IF9tWzFdO1xuICAgIHZhciBpbnB1dFJlZiA9IHVzZVJlZihudWxsKTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5wdXRSZWYuY3VycmVudDsgfSk7XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBjaGFuZ2UgaW4gdmFsdWVcbiAgICAgKi9cbiAgICB2YXIgcHJvY2Vzc0NoYW5nZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgICAgc2V0RGlydHkodHJ1ZSk7XG4gICAgICAgIHZhciBfYSA9IHJlcG9zaXRpb25DdXJzb3Ioe1xuICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQ6IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbGFzdEtleVN0cm9rZTogbGFzdEtleVN0cm9rZSxcbiAgICAgICAgICAgIHN0YXRlVmFsdWU6IHN0YXRlVmFsdWUsXG4gICAgICAgICAgICBncm91cFNlcGFyYXRvcjogZ3JvdXBTZXBhcmF0b3IsXG4gICAgICAgIH0pLCBtb2RpZmllZFZhbHVlID0gX2EubW9kaWZpZWRWYWx1ZSwgY3Vyc29yUG9zaXRpb24gPSBfYS5jdXJzb3JQb3NpdGlvbjtcbiAgICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gY2xlYW5WYWx1ZShfX2Fzc2lnbih7IHZhbHVlOiBtb2RpZmllZFZhbHVlIH0sIGNsZWFuVmFsdWVPcHRpb25zKSk7XG4gICAgICAgIGlmICh1c2VyTWF4TGVuZ3RoICYmIHN0cmluZ1ZhbHVlLnJlcGxhY2UoLy0vZywgJycpLmxlbmd0aCA+IHVzZXJNYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaW5nVmFsdWUgPT09ICcnIHx8IHN0cmluZ1ZhbHVlID09PSAnLScgfHwgc3RyaW5nVmFsdWUgPT09IGRlY2ltYWxTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIG9uVmFsdWVDaGFuZ2UgJiYgb25WYWx1ZUNoYW5nZSh1bmRlZmluZWQsIG5hbWUsIHsgZmxvYXQ6IG51bGwsIGZvcm1hdHRlZDogJycsIHZhbHVlOiAnJyB9KTtcbiAgICAgICAgICAgIHNldFN0YXRlVmFsdWUoc3RyaW5nVmFsdWUpO1xuICAgICAgICAgICAgLy8gQWx3YXlzIHNldHMgY3Vyc29yIGFmdGVyICctJyBvciBkZWNpbWFsU2VwYXJhdG9yIGlucHV0XG4gICAgICAgICAgICBzZXRDdXJzb3IoMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmluZ1ZhbHVlV2l0aG91dFNlcGFyYXRvciA9IGRlY2ltYWxTZXBhcmF0b3JcbiAgICAgICAgICAgID8gc3RyaW5nVmFsdWUucmVwbGFjZShkZWNpbWFsU2VwYXJhdG9yLCAnLicpXG4gICAgICAgICAgICA6IHN0cmluZ1ZhbHVlO1xuICAgICAgICB2YXIgbnVtYmVyVmFsdWUgPSBwYXJzZUZsb2F0KHN0cmluZ1ZhbHVlV2l0aG91dFNlcGFyYXRvcik7XG4gICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IGZvcm1hdFZhbHVlKF9fYXNzaWduKHsgdmFsdWU6IHN0cmluZ1ZhbHVlIH0sIGZvcm1hdFZhbHVlT3B0aW9ucykpO1xuICAgICAgICBpZiAoY3Vyc29yUG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBjdXJzb3IganVtcGluZ1xuICAgICAgICAgICAgdmFyIG5ld0N1cnNvciA9IGN1cnNvclBvc2l0aW9uICsgKGZvcm1hdHRlZFZhbHVlLmxlbmd0aCAtIHZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICBuZXdDdXJzb3IgPSBuZXdDdXJzb3IgPD0gMCA/IChwcmVmaXggPyBwcmVmaXgubGVuZ3RoIDogMCkgOiBuZXdDdXJzb3I7XG4gICAgICAgICAgICBzZXRDdXJzb3IobmV3Q3Vyc29yKTtcbiAgICAgICAgICAgIHNldENoYW5nZUNvdW50KGNoYW5nZUNvdW50ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0U3RhdGVWYWx1ZShmb3JtYXR0ZWRWYWx1ZSk7XG4gICAgICAgIGlmIChvblZhbHVlQ2hhbmdlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0ge1xuICAgICAgICAgICAgICAgIGZsb2F0OiBudW1iZXJWYWx1ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWQ6IGZvcm1hdHRlZFZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzdHJpbmdWYWx1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvblZhbHVlQ2hhbmdlKHN0cmluZ1ZhbHVlLCBuYW1lLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgY2hhbmdlIGV2ZW50XG4gICAgICovXG4gICAgdmFyIGhhbmRsZU9uQ2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYSA9IGV2ZW50LnRhcmdldCwgdmFsdWUgPSBfYS52YWx1ZSwgc2VsZWN0aW9uU3RhcnQgPSBfYS5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgcHJvY2Vzc0NoYW5nZSh2YWx1ZSwgc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICBvbkNoYW5nZSAmJiBvbkNoYW5nZShldmVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgZm9jdXMgZXZlbnRcbiAgICAgKi9cbiAgICB2YXIgaGFuZGxlT25Gb2N1cyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBvbkZvY3VzICYmIG9uRm9jdXMoZXZlbnQpO1xuICAgICAgICByZXR1cm4gc3RhdGVWYWx1ZSA/IHN0YXRlVmFsdWUubGVuZ3RoIDogMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBibHVyIGV2ZW50XG4gICAgICpcbiAgICAgKiBGb3JtYXQgdmFsdWUgYnkgcGFkZGluZy90cmltbWluZyBkZWNpbWFscyBpZiByZXF1aXJlZCBieVxuICAgICAqL1xuICAgIHZhciBoYW5kbGVPbkJsdXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICB2YXIgdmFsdWVPbmx5ID0gY2xlYW5WYWx1ZShfX2Fzc2lnbih7IHZhbHVlOiB2YWx1ZSB9LCBjbGVhblZhbHVlT3B0aW9ucykpO1xuICAgICAgICBpZiAodmFsdWVPbmx5ID09PSAnLScgfHwgdmFsdWVPbmx5ID09PSBkZWNpbWFsU2VwYXJhdG9yIHx8ICF2YWx1ZU9ubHkpIHtcbiAgICAgICAgICAgIHNldFN0YXRlVmFsdWUoJycpO1xuICAgICAgICAgICAgb25CbHVyICYmIG9uQmx1cihldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpeGVkRGVjaW1hbHMgPSBmaXhlZERlY2ltYWxWYWx1ZSh2YWx1ZU9ubHksIGRlY2ltYWxTZXBhcmF0b3IsIGZpeGVkRGVjaW1hbExlbmd0aCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHBhZFRyaW1WYWx1ZShmaXhlZERlY2ltYWxzLCBkZWNpbWFsU2VwYXJhdG9yLCBkZWNpbWFsU2NhbGUgIT09IHVuZGVmaW5lZCA/IGRlY2ltYWxTY2FsZSA6IGZpeGVkRGVjaW1hbExlbmd0aCk7XG4gICAgICAgIHZhciBudW1iZXJWYWx1ZSA9IHBhcnNlRmxvYXQobmV3VmFsdWUucmVwbGFjZShkZWNpbWFsU2VwYXJhdG9yLCAnLicpKTtcbiAgICAgICAgdmFyIGZvcm1hdHRlZFZhbHVlID0gZm9ybWF0VmFsdWUoX19hc3NpZ24oX19hc3NpZ24oe30sIGZvcm1hdFZhbHVlT3B0aW9ucyksIHsgdmFsdWU6IG5ld1ZhbHVlIH0pKTtcbiAgICAgICAgaWYgKG9uVmFsdWVDaGFuZ2UgJiYgZm9ybWF0VmFsdWVPbkJsdXIpIHtcbiAgICAgICAgICAgIG9uVmFsdWVDaGFuZ2UobmV3VmFsdWUsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICBmbG9hdDogbnVtYmVyVmFsdWUsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkOiBmb3JtYXR0ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRTdGF0ZVZhbHVlKGZvcm1hdHRlZFZhbHVlKTtcbiAgICAgICAgb25CbHVyICYmIG9uQmx1cihldmVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUga2V5IGRvd24gZXZlbnRcbiAgICAgKlxuICAgICAqIEluY3JlYXNlIG9yIGRlY3JlYXNlIHZhbHVlIGJ5IHN0ZXBcbiAgICAgKi9cbiAgICB2YXIgaGFuZGxlT25LZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBrZXkgPSBldmVudC5rZXk7XG4gICAgICAgIHNldExhc3RLZXlTdHJva2Uoa2V5KTtcbiAgICAgICAgaWYgKHN0ZXAgJiYgKGtleSA9PT0gJ0Fycm93VXAnIHx8IGtleSA9PT0gJ0Fycm93RG93bicpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgc2V0Q3Vyc29yKHN0YXRlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBwYXJzZUZsb2F0KHVzZXJWYWx1ZSAhPSBudWxsXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcodXNlclZhbHVlKS5yZXBsYWNlKGRlY2ltYWxTZXBhcmF0b3IsICcuJylcbiAgICAgICAgICAgICAgICA6IGNsZWFuVmFsdWUoX19hc3NpZ24oeyB2YWx1ZTogc3RhdGVWYWx1ZSB9LCBjbGVhblZhbHVlT3B0aW9ucykpKSB8fCAwO1xuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0ga2V5ID09PSAnQXJyb3dVcCcgPyBjdXJyZW50VmFsdWUgKyBzdGVwIDogY3VycmVudFZhbHVlIC0gc3RlcDtcbiAgICAgICAgICAgIGlmIChtaW4gIT09IHVuZGVmaW5lZCAmJiBuZXdWYWx1ZSA8IE51bWJlcihtaW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkICYmIG5ld1ZhbHVlID4gTnVtYmVyKG1heCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZml4ZWRMZW5ndGggPSBTdHJpbmcoc3RlcCkuaW5jbHVkZXMoJy4nKVxuICAgICAgICAgICAgICAgID8gTnVtYmVyKFN0cmluZyhzdGVwKS5zcGxpdCgnLicpWzFdLmxlbmd0aClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHByb2Nlc3NDaGFuZ2UoU3RyaW5nKGZpeGVkTGVuZ3RoID8gbmV3VmFsdWUudG9GaXhlZChmaXhlZExlbmd0aCkgOiBuZXdWYWx1ZSkucmVwbGFjZSgnLicsIGRlY2ltYWxTZXBhcmF0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICBvbktleURvd24gJiYgb25LZXlEb3duKGV2ZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBrZXkgdXAgZXZlbnRcbiAgICAgKlxuICAgICAqIE1vdmUgY3Vyc29yIGlmIHRoZXJlIGlzIGEgc3VmZml4IHRvIHByZXZlbnQgdXNlciB0eXBpbmcgcGFzdCBzdWZmaXhcbiAgICAgKi9cbiAgICB2YXIgaGFuZGxlT25LZXlVcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIga2V5ID0gZXZlbnQua2V5LCBzZWxlY3Rpb25TdGFydCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIGlmIChrZXkgIT09ICdBcnJvd1VwJyAmJiBrZXkgIT09ICdBcnJvd0Rvd24nICYmIHN0YXRlVmFsdWUgIT09ICctJykge1xuICAgICAgICAgICAgdmFyIHN1ZmZpeF8xID0gZ2V0U3VmZml4KHN0YXRlVmFsdWUsIHsgZ3JvdXBTZXBhcmF0b3I6IGdyb3VwU2VwYXJhdG9yLCBkZWNpbWFsU2VwYXJhdG9yOiBkZWNpbWFsU2VwYXJhdG9yIH0pO1xuICAgICAgICAgICAgaWYgKHN1ZmZpeF8xICYmIHNlbGVjdGlvblN0YXJ0ICYmIHNlbGVjdGlvblN0YXJ0ID4gc3RhdGVWYWx1ZS5sZW5ndGggLSBzdWZmaXhfMS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdDdXJzb3IgPSBzdGF0ZVZhbHVlLmxlbmd0aCAtIHN1ZmZpeF8xLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRSZWYuY3VycmVudC5zZXRTZWxlY3Rpb25SYW5nZShuZXdDdXJzb3IsIG5ld0N1cnNvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9uS2V5VXAgJiYgb25LZXlVcChldmVudCk7XG4gICAgfTtcbiAgICAvLyBVcGRhdGUgc3RhdGUgaWYgdXNlclZhbHVlIGNoYW5nZXMgdG8gdW5kZWZpbmVkXG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHVzZXJWYWx1ZSA9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXRTdGF0ZVZhbHVlKCcnKTtcbiAgICAgICAgfVxuICAgIH0sIFtkZWZhdWx0VmFsdWUsIHVzZXJWYWx1ZV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHByZXZlbnQgY3Vyc29yIGp1bXBpbmcgaWYgZWRpdGluZyB2YWx1ZVxuICAgICAgICBpZiAoZGlydHkgJiZcbiAgICAgICAgICAgIHN0YXRlVmFsdWUgIT09ICctJyAmJlxuICAgICAgICAgICAgaW5wdXRSZWYuY3VycmVudCAmJlxuICAgICAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gaW5wdXRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgaW5wdXRSZWYuY3VycmVudC5zZXRTZWxlY3Rpb25SYW5nZShjdXJzb3IsIGN1cnNvcik7XG4gICAgICAgIH1cbiAgICB9LCBbc3RhdGVWYWx1ZSwgY3Vyc29yLCBpbnB1dFJlZiwgZGlydHksIGNoYW5nZUNvdW50XSk7XG4gICAgLyoqXG4gICAgICogSWYgdXNlciBoYXMgb25seSBlbnRlcmVkIFwiLVwiIG9yIGRlY2ltYWwgc2VwYXJhdG9yLFxuICAgICAqIGtlZXAgdGhlIGNoYXIgdG8gYWxsb3cgdGhlbSB0byBlbnRlciBuZXh0IHZhbHVlXG4gICAgICovXG4gICAgdmFyIGdldFJlbmRlclZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodXNlclZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICAgIHN0YXRlVmFsdWUgIT09ICctJyAmJlxuICAgICAgICAgICAgKCFkZWNpbWFsU2VwYXJhdG9yIHx8IHN0YXRlVmFsdWUgIT09IGRlY2ltYWxTZXBhcmF0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUoX19hc3NpZ24oX19hc3NpZ24oe30sIGZvcm1hdFZhbHVlT3B0aW9ucyksIHsgZGVjaW1hbFNjYWxlOiBkaXJ0eSA/IHVuZGVmaW5lZCA6IGRlY2ltYWxTY2FsZSwgdmFsdWU6IFN0cmluZyh1c2VyVmFsdWUpIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGVWYWx1ZTtcbiAgICB9O1xuICAgIHZhciBpbnB1dFByb3BzID0gX19hc3NpZ24oeyB0eXBlOiAndGV4dCcsIGlucHV0TW9kZTogJ2RlY2ltYWwnLCBpZDogaWQsIG5hbWU6IG5hbWUsIGNsYXNzTmFtZTogY2xhc3NOYW1lLCBvbkNoYW5nZTogaGFuZGxlT25DaGFuZ2UsIG9uQmx1cjogaGFuZGxlT25CbHVyLCBvbkZvY3VzOiBoYW5kbGVPbkZvY3VzLCBvbktleURvd246IGhhbmRsZU9uS2V5RG93biwgb25LZXlVcDogaGFuZGxlT25LZXlVcCwgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLCBkaXNhYmxlZDogZGlzYWJsZWQsIHZhbHVlOiBnZXRSZW5kZXJWYWx1ZSgpLCByZWY6IGlucHV0UmVmIH0sIHByb3BzKTtcbiAgICBpZiAoY3VzdG9tSW5wdXQpIHtcbiAgICAgICAgdmFyIEN1c3RvbUlucHV0ID0gY3VzdG9tSW5wdXQ7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEN1c3RvbUlucHV0LCBfX2Fzc2lnbih7fSwgaW5wdXRQcm9wcykpO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIF9fYXNzaWduKHt9LCBpbnB1dFByb3BzKSk7XG59KTtcbkN1cnJlbmN5SW5wdXQuZGlzcGxheU5hbWUgPSAnQ3VycmVuY3lJbnB1dCc7XG5cbmV4cG9ydCB7IGNsZWFuVmFsdWUsIEN1cnJlbmN5SW5wdXQgYXMgZGVmYXVsdCwgZm9ybWF0VmFsdWUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-currency-input-field/dist/index.esm.js\n");

/***/ })

};
;